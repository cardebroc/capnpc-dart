// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
// Licensed under the MIT License:
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

use std::collections;
use std::collections::HashSet;
use std::path::{Path, PathBuf};

use capnp;
use capnp::Error;
use convert_case::{Case, Casing};

use self::FormattedText::{BlankLine, Branch, Indent, Line};
use crate::codegen_types::{do_branding, Leaf, RustNodeInfo, RustTypeInfo, TypeParameterTexts};
use crate::convert_io_err;
use crate::pointer_constants::generate_pointer_constant;
use crate::schema_capnp;

/// An invocation of the capnpc-rust code generation plugin.
pub struct CodeGenerationCommand {
    output_directory: PathBuf,
    default_parent_module: Vec<String>,
}

impl CodeGenerationCommand {
    /// Creates a new code generation command with default options.
    pub fn new() -> CodeGenerationCommand {
        CodeGenerationCommand {
            output_directory: PathBuf::new(),
            default_parent_module: Vec::new(),
        }
    }

    /// Sets the output directory.
    pub fn output_directory<P>(&mut self, path: P) -> &mut Self
    where
        P: AsRef<Path>,
    {
        self.output_directory = path.as_ref().to_path_buf();
        self
    }

    /// Generates Rust code according to a `schema_capnp::code_generator_request` read from `inp`.
    pub fn run<T>(&mut self, inp: T) -> ::capnp::Result<()>
    where
        T: std::io::Read,
    {
        use capnp::serialize;
        use std::io::Write;

        let message = serialize::read_message(
            ReadWrapper { inner: inp },
            capnp::message::ReaderOptions::new(),
        )?;

        let gen = GeneratorContext::new(&message)?;

        for requested_file in gen.request.get_requested_files()?.iter() {
            let id = requested_file.get_id();
            let mut filepath = self.output_directory.to_path_buf();
            let requested = ::std::path::PathBuf::from(requested_file.get_filename()?);
            filepath.push(requested);
            if let Some(parent) = filepath.parent() {
                ::std::fs::create_dir_all(parent).map_err(convert_io_err)?;
            }

            let root_name = path_to_stem_string(&filepath)?.replace("-", "_");

            let mut addl_files = Vec::new();
            let node = generate_node(&gen, id, &root_name, None, &mut addl_files)?;
            addl_files.push((format!(""), node));

            for (file_name, file_contents) in &addl_files {
                filepath.set_file_name(&format!("{}_{}capnp.dart", root_name, file_name));

                let mut imports = Vec::new();
                for import in requested_file.get_imports()?.iter() {
                    let name = gen.get_last_name(import.get_id())?;
                    imports.push(Line("// ignore: unused_import".to_string()));
                    imports.push(Line(format!("import '{}.dart';", name)));
                }
                
                /* for (file_name, _) in &addl_files {
                    imports.push(Line("// ignore: unused_import".to_string()));
                    imports.push(Line(format!("import '{}_{}capnp.dart' as {}_capnp_{};", root_name, file_name, root_name, file_name)));
                } */
    
                let lines = Branch(vec![
                    Line(
                        "// @generated by the capnpc-dart plugin to the Cap'n Proto schema compiler."
                            .to_string(),
                    ),
                    Line("// DO NOT EDIT.".to_string()),
                    Line(format!("// source: {}", requested_file.get_filename()?)),
                    BlankLine,
                    Line("// ignore: unused_import".to_string()),
                    Line("import 'package:capnp/capnp.dart' as capnp;".to_string()),
                    Line("// ignore: unused_import".to_string()),
                    Line("import 'package:capnp/rpc/capnp_rpc.dart' as capnp_rpc;".to_string()),
                    Line("import 'dart:core' as core;".to_string()),
                    Line("// ignore: unused_import".to_string()),
                    Line("import 'dart:typed_data' as typed_data;".to_string()),
                    Line("// ignore: unused_import".to_string()),
                    Line("import 'dart:async' as async;".to_string()),
                    BlankLine,
                    Branch(imports),
                    BlankLine,
                    file_contents.clone(),
                ]);
    
                let text = stringify(&lines);
    
                let previous_text = ::std::fs::read(&filepath);
                if previous_text.is_ok() && previous_text.unwrap() == text.as_bytes() {
                    // File is unchanged. Do not write it so that builds with the
                    // output as part of the source work in read-only filesystems
                    // and so timestamp-based build systems and watchers do not get
                    // confused.
                    continue;
                }
    
                // It would be simpler to use the ? operator instead of a pattern match, but then the error message
                // would not include `filepath`.
                match ::std::fs::File::create(&filepath) {
                    Ok(ref mut writer) => {
                        writer.write_all(text.as_bytes()).map_err(convert_io_err)?;
                    }
                    Err(e) => {
                        let _ = writeln!(
                            &mut ::std::io::stderr(),
                            "could not open file {:?} for writing: {}",
                            filepath,
                            e
                        );
                        return Err(convert_io_err(e));
                    }
                }
            }

            
        }
        Ok(())
    }
}

pub struct GeneratorContext<'a> {
    pub request: schema_capnp::code_generator_request::Reader<'a>,
    pub node_map: collections::hash_map::HashMap<u64, schema_capnp::node::Reader<'a>>,
    pub scope_map: collections::hash_map::HashMap<u64, Vec<String>>,
}

impl<'a> GeneratorContext<'a> {
    pub fn new(
        message: &'a capnp::message::Reader<capnp::serialize::OwnedSegments>,
    ) -> ::capnp::Result<GeneratorContext<'a>> {
        GeneratorContext::new_with_default_parent_module(&[], message)
    }

    fn new_with_default_parent_module(
        default_parent_module: &[String],
        message: &'a capnp::message::Reader<capnp::serialize::OwnedSegments>,
    ) -> ::capnp::Result<GeneratorContext<'a>> {
        let mut default_parent_module_scope = vec![]; //vec!["crate".to_string()];
        default_parent_module_scope.extend_from_slice(default_parent_module);

        let mut gen = GeneratorContext {
            request: message.get_root()?,
            node_map: collections::hash_map::HashMap::<u64, schema_capnp::node::Reader<'a>>::new(),
            scope_map: collections::hash_map::HashMap::<u64, Vec<String>>::new(),
        };

        for node in gen.request.get_nodes()?.iter() {
            gen.node_map.insert(node.get_id(), node);
        }

        for requested_file in gen.request.get_requested_files()?.iter() {
            let id = requested_file.get_id();

            let imports = requested_file.get_imports()?;
            for import in imports.iter() {
                let importpath = ::std::path::Path::new(import.get_name()?);
                let root_name: String = format!(
                    "{}_capnp",
                    path_to_stem_string(importpath)?.replace("-", "_")
                );
                populate_scope_map(
                    &gen.node_map,
                    &mut gen.scope_map,
                    default_parent_module_scope.clone(),
                    root_name,
                    NameKind::Verbatim,
                    import.get_id(),
                )?;
            }

            let root_name = path_to_stem_string(requested_file.get_filename()?)?;
            let root_mod = format!("{}_capnp", root_name.replace("-", "_"));
            populate_scope_map(
                &gen.node_map,
                &mut gen.scope_map,
                default_parent_module_scope.clone(),
                root_mod,
                NameKind::Verbatim,
                id,
            )?;
        }
        Ok(gen)
    }

    fn get_last_name<'b>(&'b self, id: u64) -> ::capnp::Result<&'b str> {
        match self.scope_map.get(&id) {
            None => Err(Error::failed(format!("node not found: {}", id))),
            Some(v) => match v.last() {
                None => Err(Error::failed(format!("node has no scope: {}", id))),
                Some(n) => Ok(&n),
            },
        }
    }

    fn get_full_path<'b>(&'b self, id: u64) -> ::capnp::Result<String> {
        match self.scope_map.get(&id) {
            None => Err(Error::failed(format!("node not found: {}", id))),
            Some(v) => Ok(v.iter()
                .fold(String::new(), |a, b| format!("{}/{}", a, b))
            )
            /*match v.last() {
                None => Err(Error::failed(format!("node has no scope: {}", id))),
                Some(n) => Ok(&n),
            }*/,
        }
    }
}

fn path_to_stem_string<P: AsRef<::std::path::Path>>(path: P) -> ::capnp::Result<String> {
    match path.as_ref().file_stem() {
        None => Err(Error::failed(format!(
            "file has no stem: {:?}",
            path.as_ref()
        ))),
        Some(stem) => match stem.to_owned().into_string() {
            Err(os_string) => Err(Error::failed(format!("bad filename: {:?}", os_string))),
            Ok(s) => Ok(s.to_case(Case::Snake)),
        },
    }
}

fn snake_to_upper_case(s: &str) -> String {
    let mut result_chars: Vec<char> = Vec::new();
    for c in s.chars() {
        if c == '_' {
            result_chars.push('_');
        } else {
            result_chars.push(c.to_ascii_uppercase());
        }
    }
    result_chars.into_iter().collect()
}

fn camel_to_snake_case(s: &str) -> String {
    let mut result_chars: Vec<char> = Vec::new();
    let mut first_char = true;
    for c in s.chars() {
        if c.is_uppercase() && !first_char {
            result_chars.push('_');
        }
        result_chars.push(c.to_ascii_lowercase());
        first_char = false;
    }
    result_chars.into_iter().collect()
}

fn capitalize_first_letter(s: &str) -> String {
    let mut result_chars: Vec<char> = Vec::new();
    for c in s.chars() {
        result_chars.push(c)
    }
    result_chars[0] = result_chars[0].to_ascii_uppercase();
    result_chars.into_iter().collect()
}

fn format_u64(value: u64) -> String {
    format!("{:#x}", value)
}

#[derive(PartialEq, Clone, Debug)]
pub enum FormattedText {
    Indent(Box<FormattedText>),
    Branch(Vec<FormattedText>),
    Line(String),
    BlankLine,
}

fn to_lines(ft: &FormattedText, indent: usize) -> Vec<String> {
    match *ft {
        Indent(ref ft) => {
            return to_lines(&**ft, indent + 1);
        }
        Branch(ref fts) => {
            let mut result = Vec::new();
            for ft in fts.iter() {
                for line in to_lines(ft, indent).iter() {
                    result.push(line.clone()); // TODO there's probably a better way to do this.
                }
            }
            return result;
        }
        Line(ref s) => {
            let mut s1: String = ::std::iter::repeat(' ').take(indent * 2).collect();
            s1.push_str(&s);
            return vec![s1.to_string()];
        }
        BlankLine => return vec!["".to_string()],
    }
}

fn stringify(ft: &FormattedText) -> String {
    let mut result = to_lines(ft, 0).join("\n");
    result.push_str("\n");
    result.to_string()
}

const DART_KEYWORDS: [&'static str; 63] = [
    "abstract",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "covariant",
    "default",
    "deferred",
    "do",
    "dynamic",
    "else",
    "enum",
    "export",
    "extends",
    "extension",
    "external",
    "factory",
    "false",
    "final",
    "finally",
    "for",
    "Function",
    "get",
    "hide",
    "if",
    "implements",
    "import",
    "in",
    "interface",
    "is",
    "late",
    "library",
    "mixin",
    "new",
    "null",
    "on",
    "operator",
    "part",
    "required",
    "rethrow",
    "return",
    "set",
    "show",
    "static",
    "super",
    "switch",
    "sync",
    "this",
    "throw",
    "true",
    "try",
    "typedef",
    "var",
    "void",
    "while",
    "with",
    "yield",
];

fn module_name(camel_case: &str) -> String {
    // let mut name = camel_to_snake_case(camel_case);
    let mut name = camel_case.to_string();
    if DART_KEYWORDS.contains(&&*name) {
        name.push('_');
    }
    name
}

const NAME_ANNOTATION_ID: u64 = 0xd06560049a756e9e;

fn name_annotation_value(annotation: schema_capnp::annotation::Reader) -> capnp::Result<&str> {
    if let schema_capnp::value::Text(t) = annotation.get_value()?.which()? {
        let name = t?;
        for c in name.chars() {
            if !(c == '_' || c.is_alphanumeric()) {
                return Err(capnp::Error::failed(format!(
                    "dart.name annotation value must only contain alphanumeric characters and '_'"
                )));
            }
        }
        Ok(name)
    } else {
        Err(capnp::Error::failed(format!(
            "expected dart.name annotation value to be of type Text"
        )))
    }
}

fn get_field_name(field: schema_capnp::field::Reader) -> capnp::Result<&str> {
    for annotation in field.get_annotations()?.iter() {
        if annotation.get_id() == NAME_ANNOTATION_ID {
            return name_annotation_value(annotation);
        }
    }
    field.get_name()
}

fn get_enumerant_name(enumerant: schema_capnp::enumerant::Reader) -> capnp::Result<&str> {
    for annotation in enumerant.get_annotations()?.iter() {
        if annotation.get_id() == NAME_ANNOTATION_ID {
            return name_annotation_value(annotation);
        }
    }
    enumerant.get_name()
}

enum NameKind {
    // avoid Dart keywords
    Module,

    // don't modify
    Verbatim,
}

fn capnp_name_to_rust_name(capnp_name: &str, name_kind: NameKind) -> String {
    match name_kind {
        NameKind::Module => module_name(capnp_name),
        NameKind::Verbatim => capnp_name.to_string(),
    }
}

fn escape(mut org: String) -> String {
    let org_ref: &str = &org;
    if DART_KEYWORDS.contains(&org_ref) {
        org += "_";
    }
    org
}

fn populate_scope_map(
    node_map: &collections::hash_map::HashMap<u64, schema_capnp::node::Reader>,
    scope_map: &mut collections::hash_map::HashMap<u64, Vec<String>>,
    mut ancestor_scope_names: Vec<String>,
    mut current_node_name: String,
    current_name_kind: NameKind,
    node_id: u64,
) -> ::capnp::Result<()> {
    // unused nodes in imported files might be omitted from the node map
    let node_reader = match node_map.get(&node_id) {
        Some(node) => node,
        None => return Ok(()),
    };

    for annotation in node_reader.get_annotations()?.iter() {
        if annotation.get_id() == NAME_ANNOTATION_ID {
            current_node_name = name_annotation_value(annotation)?.to_string();
        }
    }

    let mut scope_names = ancestor_scope_names;
    scope_names.push(capnp_name_to_rust_name(
        &current_node_name,
        current_name_kind,
    ));

    scope_map.insert(node_id, scope_names.clone());

    let nested_nodes = node_reader.get_nested_nodes()?;
    for nested_node in nested_nodes.iter() {
        let nested_node_id = nested_node.get_id();
        match node_map.get(&nested_node_id) {
            None => {}
            Some(node_reader) => match node_reader.which() {
                Ok(schema_capnp::node::Enum(_enum_reader)) => {
                    populate_scope_map(
                        node_map,
                        scope_map,
                        scope_names.clone(),
                        nested_node.get_name()?.to_string(),
                        NameKind::Verbatim,
                        nested_node_id,
                    )?;
                }
                _ => {
                    populate_scope_map(
                        node_map,
                        scope_map,
                        scope_names.clone(),
                        nested_node.get_name()?.to_string(),
                        NameKind::Module,
                        nested_node_id,
                    )?;
                }
            },
        }
    }

    match node_reader.which() {
        Ok(schema_capnp::node::Struct(struct_reader)) => {
            let fields = struct_reader.get_fields()?;
            for field in fields.iter() {
                match field.which() {
                    Ok(schema_capnp::field::Group(group)) => {
                        populate_scope_map(
                            node_map,
                            scope_map,
                            scope_names.clone(),
                            get_field_name(field)?.to_string(),
                            NameKind::Module,
                            group.get_type_id(),
                        )?;
                    }
                    _ => {}
                }
            }
        }
        _ => {}
    }
    Ok(())
}

fn prim_default(value: &schema_capnp::value::Reader) -> ::capnp::Result<Option<String>> {
    use crate::schema_capnp::value;
    match value.which()? {
        value::Bool(false)
        | value::Int8(0)
        | value::Int16(0)
        | value::Int32(0)
        | value::Int64(0)
        | value::Uint8(0)
        | value::Uint16(0)
        | value::Uint32(0)
        | value::Uint64(0) => Ok(None),

        value::Bool(true) => Ok(Some(format!("true"))),
        value::Int8(i) => Ok(Some(i.to_string())),
        value::Int16(i) => Ok(Some(i.to_string())),
        value::Int32(i) => Ok(Some(i.to_string())),
        value::Int64(i) => Ok(Some(i.to_string())),
        value::Uint8(i) => Ok(Some(i.to_string())),
        value::Uint16(i) => Ok(Some(i.to_string())),
        value::Uint32(i) => Ok(Some(i.to_string())),
        value::Uint64(i) => Ok(Some(i.to_string())),
        value::Float32(f) => match f.classify() {
            ::std::num::FpCategory::Zero => Ok(None),
            _ => todo!(), // Ok(Some(format!("{}u32", f.to_bits().to_string()))),
        },
        value::Float64(f) => match f.classify() {
            ::std::num::FpCategory::Zero => Ok(None),
            _ => todo!(), // Ok(Some(format!("{}u64", f.to_bits().to_string()))),
        },
        _ => Err(Error::failed(
            "Non-primitive value found where primitive was expected.".to_string(),
        )),
    }
}

fn handle_list(
    gen: &GeneratorContext,
    node_id: u64,
    element_type: schema_capnp::type_::Reader,
) -> capnp::Result<(String, String, Option<String>)> {
    use schema_capnp::type_;

    Ok(match element_type.which()? {
        type_::Which::Void(_) => todo!(),
        type_::Which::Bool(_) => (
            "typed_data.UnmodifiableBoolListView".to_string(),
            "getBoolList".to_string(),
            None,
        ),
        type_::Which::Int8(_) => (
            "typed_data.UnmodifiableInt8ListView".to_string(),
            "getInt8List".to_string(),
            None,
        ),
        type_::Which::Int16(_) => (
            "typed_data.UnmodifiableInt16ListView".to_string(),
            "getInt16List".to_string(),
            None,
        ),
        type_::Which::Int32(_) => (
            "typed_data.UnmodifiableInt32ListView".to_string(),
            "getInt32List".to_string(),
            None,
        ),
        type_::Which::Int64(_) => (
            "typed_data.UnmodifiableInt64ListView".to_string(),
            "getInt64List".to_string(),
            None,
        ),
        type_::Which::Uint8(_) => (
            "typed_data.UnmodifiableUint8ListView".to_string(),
            "getUInt8List".to_string(),
            None,
        ),
        type_::Which::Uint16(_) => (
            "typed_data.UnmodifiableUint16ListView".to_string(),
            "getUInt16List".to_string(),
            None,
        ),
        type_::Which::Uint32(_) => (
            "typed_data.UnmodifiableUint32ListView".to_string(),
            "getUInt32List".to_string(),
            None,
        ),
        type_::Which::Uint64(_) => (
            "typed_data.UnmodifiableUint64ListView".to_string(),
            "getUInt64List".to_string(),
            None,
        ),
        type_::Which::Float32(_) => (
            "typed_data.UnmodifiableFloat32ListView".to_string(),
            "getFloat32List".to_string(),
            None,
        ),
        type_::Which::Float64(_) => (
            "typed_data.UnmodifiableFloat64ListView".to_string(),
            "getFloat64List".to_string(),
            None,
        ),
        type_::Which::Text(_) => (
            "core.List<core.String>".to_string(),
            "getTextList".to_string(),
            None,
            ),
        type_::Which::Data(_) => todo!(),
        type_::Which::List(inner) => {
            let inner = handle_type(gen, node_id, inner.get_element_type()?)?;
            let ty = format!("capnp.UnmodifiableCompositeListView<{}>", inner.0);
            (ty, "getCompositeList".to_string(), inner.2)
        }
        type_::Which::Enum(inner) => todo!(),
        type_::Which::Struct(inner) => {
            let struct_name = gen.get_last_name(inner.get_type_id())?;
            let ty = format!("capnp.UnmodifiableCompositeListView<{}Reader>", struct_name);
            (
                ty,
                "getCompositeList".to_string(),
                Some(format!(", {}().reader", struct_name)),
            )
        }
        type_::Which::Interface(_) => {
            // TODO: Change to Capability Pointer
            (
                "capnp.CapabilityPointer".to_string(),
                "getCapabilityPointer".to_string(),
                None,
            )
        }
        type_::Which::AnyPointer(_) => (
            "capnp.Pointer".to_string(),
            "getAnyPointer".to_string(),
            None,
        ),
    })
}

fn handle_type(
    gen: &GeneratorContext,
    node_id: u64,
    input: schema_capnp::type_::Reader,
) -> capnp::Result<(String, String, Option<String>)> {
    use schema_capnp::type_;

    Ok(match input.which()? {
        type_::Which::Void(_) => ("capnp.NullableVoid".to_string(), "getVoid".to_string(), None),
        type_::Which::Bool(_) => ("core.bool".to_string(), "getBool".to_string(), None),
        type_::Which::Int8(_) => ("core.int".to_string(), "getInt8".to_string(), None),
        type_::Which::Int16(_) => ("core.int".to_string(), "getInt16".to_string(), None),
        type_::Which::Int32(_) => ("core.int".to_string(), "getInt32".to_string(), None),
        type_::Which::Int64(_) => ("core.int".to_string(), "getInt64".to_string(), None),
        type_::Which::Uint8(_) => ("core.int".to_string(), "getUInt8".to_string(), None),
        type_::Which::Uint16(_) => ("core.int".to_string(), "getUInt16".to_string(), None),
        type_::Which::Uint32(_) => ("core.int".to_string(), "getUInt32".to_string(), None),
        type_::Which::Uint64(_) => ("core.int".to_string(), "getUInt64".to_string(), None),
        type_::Which::Float32(_) => ("core.double".to_string(), "getFloat32".to_string(), None),
        type_::Which::Float64(_) => ("core.double".to_string(), "getFloat64".to_string(), None),
        type_::Which::Text(_) => ("core.String".to_string(), "getText".to_string(), None),
        type_::Which::Data(_) => (
            "typed_data.UnmodifiableUint8ListView".to_string(),
            "getData".to_string(),
            None,
        ),
        type_::Which::List(ot1) => {
            let element_type = ot1.get_element_type()?;
            handle_list(gen, node_id, element_type)?
        }
        type_::Which::Enum(inner) => {
            let enum_name = gen.get_last_name(inner.get_type_id())?;
            (
                enum_name.to_string(),
                "getEnum".to_string(),
                Some(format!(", {}.values", enum_name)),
            )
        }
        type_::Which::Struct(st) => {
            let struct_name = gen.get_last_name(st.get_type_id())?;
            (
                format!("{}Reader", struct_name),
                "getStruct".to_string(),
                Some(format!(", {}().reader", struct_name)),
            )
        }
        type_::Which::Interface(interface) => {
            // dbg!(&gen.scope_map[&interface.get_type_id()], &gen.scope_map[&node_id]);
            let header = "";

            let client_name = format!("{}{}Client", header, gen.get_last_name(interface.get_type_id())?);
            (
                client_name.clone(),
                "getClient".to_string(),
                Some(format!(", {}{}Client.fromRaw", header, gen.get_last_name(interface.get_type_id())?)),
            )
        }
        type_::Which::AnyPointer(_) => (
            "capnp.Pointer".to_string(),
            "getAnyPointer".to_string(),
            None,
        ),
    })
}

enum WriteResult {
    Simple(String, String),
    Enum(String),
    Struct(String),
    List(String, String, Option<String>),
    AnyPointer,
}

fn handle_write_list(
    gen: &GeneratorContext,
    input: schema_capnp::type_::Reader,
) -> capnp::Result<WriteResult> {
    use schema_capnp::type_;
    Ok(match input.which()? {
        type_::Which::Void(_) => todo!(),
        type_::Which::Bool(_) => WriteResult::List(
            "capnp.BoolList".to_string(),
            "segmentView.newBoolList".to_string(),
            None,
        ),
        type_::Which::Int8(_) => WriteResult::List(
            "capnp.Int8List".to_string(),
            "segmentView.newInt8List".to_string(),
            None,
        ),
        type_::Which::Int16(_) => WriteResult::List(
            "capnp.Int16List".to_string(),
            "segmentView.newUInt16List".to_string(),
            None,
        ),
        type_::Which::Int32(_) => WriteResult::List(
            "capnp.Int32List".to_string(),
            "segmentView.newUInt32List".to_string(),
            None,
        ),
        type_::Which::Int64(_) => WriteResult::List(
            "capnp.Int64List".to_string(),
            "segmentView.newUInt64List".to_string(),
            None,
        ),
        type_::Which::Uint8(_) => WriteResult::List(
            "capnp.UInt8List".to_string(),
            "segmentView.newUInt8List".to_string(),
            None,
        ),
        type_::Which::Uint16(_) => WriteResult::List(
            "capnp.UInt16List".to_string(),
            "segmentView.newUInt16List".to_string(),
            None,
        ),
        type_::Which::Uint32(_) => WriteResult::List(
            "capnp.UInt32List".to_string(),
            "segmentView.newUInt32List".to_string(),
            None,
        ),
        type_::Which::Uint64(_) => WriteResult::List(
            "capnp.UInt64List".to_string(),
            "segmentView.newUInt64List".to_string(),
            None,
        ),
        type_::Which::Float32(_) => WriteResult::List(
            "capnp.Float32List".to_string(),
            "segmentView.newFloat32List".to_string(),
            None,
        ),
        type_::Which::Float64(_) => WriteResult::List(
            "capnp.Float64List".to_string(),
            "segmentView.newFloa64List".to_string(),
            None,
        ),
        type_::Which::Text(_) => WriteResult::List(
            "capnp.TextList".to_string(),
            "newTextList".to_string(),
            None,
        ),
        type_::Which::Data(_) => WriteResult::List(
            "capnp.DataList".to_string(),
            "newDataList".to_string(),
            None,
        ),
        type_::Which::List(_) => todo!("List(List(_)) not yet implemented"),
        type_::Which::Enum(en) => {
            let enum_name = gen.get_last_name(en.get_type_id())?;
            let ty = format!("capnp.EnumList<{}>", enum_name);
            let builder = format!("newEnumList");
            let extra = format!("");
            WriteResult::List(ty, builder, Some(extra))
        }
        type_::Which::Struct(st) => {
            let struct_name = gen.get_last_name(st.get_type_id())?;
            let ty = format!("capnp.CompositeList<{}Builder>", struct_name);
            let builder = format!("newCompositeList");
            let extra = Some(format!(", {}().builder", struct_name));
            WriteResult::List(ty, builder, extra)
        }
        type_::Which::Interface(_) => WriteResult::List(
            "capnp.CapabilityList".to_string(),
            "newCapabilityList".to_string(),
            None,
        ),
        type_::Which::AnyPointer(_) => unimplemented!("List(AnyPointer) not implemented"),
    })
}

fn handle_write_type(
    gen: &GeneratorContext,
    input: schema_capnp::type_::Reader,
) -> capnp::Result<WriteResult> {
    use schema_capnp::type_;

    Ok(match input.which()? {
        type_::Which::Void(_) => WriteResult::Simple("capnp.NullableVoid".to_string(), "setVoid".to_string()),
        type_::Which::Bool(_) => {
            WriteResult::Simple("core.bool".to_string(), "setBool".to_string())
        }
        type_::Which::Int8(_) => WriteResult::Simple("core.int".to_string(), "setInt8".to_string()),
        type_::Which::Int16(_) => {
            WriteResult::Simple("core.int".to_string(), "setInt16".to_string())
        }
        type_::Which::Int32(_) => {
            WriteResult::Simple("core.int".to_string(), "setInt32".to_string())
        }
        type_::Which::Int64(_) => {
            WriteResult::Simple("core.int".to_string(), "setInt64".to_string())
        }
        type_::Which::Uint8(_) => {
            WriteResult::Simple("core.int".to_string(), "setUInt8".to_string())
        }
        type_::Which::Uint16(_) => {
            WriteResult::Simple("core.int".to_string(), "setUInt16".to_string())
        }
        type_::Which::Uint32(_) => {
            WriteResult::Simple("core.int".to_string(), "setUInt32".to_string())
        }
        type_::Which::Uint64(_) => {
            WriteResult::Simple("core.int".to_string(), "setUInt64".to_string())
        }
        type_::Which::Float32(_) => {
            WriteResult::Simple("core.double".to_string(), "setFloat32".to_string())
        }
        type_::Which::Float64(_) => {
            WriteResult::Simple("core.double".to_string(), "setFloat64".to_string())
        }
        type_::Which::Text(_) => {
            WriteResult::Simple("core.String".to_string(), "setText".to_string())
        }
        type_::Which::Data(_) => {
            WriteResult::Simple("typed_data.ByteBuffer".to_string(), "setData".to_string())
        }
        type_::Which::List(ot1) => {
            let element_type = ot1.get_element_type()?;
            handle_write_list(gen, element_type)?
        }
        type_::Which::Enum(inner) => {
            let enum_name = gen.get_last_name(inner.get_type_id())?;
            WriteResult::Enum(enum_name.to_string())
        }
        type_::Which::Struct(st) => {
            let struct_name = gen.get_last_name(st.get_type_id())?;
            WriteResult::Struct(struct_name.to_string())
        }
        type_::Which::Interface(_) => {
            // TODO Change to Capability Pointer
            WriteResult::AnyPointer
        }
        type_::Which::AnyPointer(_) => {
            WriteResult::AnyPointer
        }
    })
}

fn build_offset(offset: usize, input: schema_capnp::type_::Reader) -> String {
    let is_ptr = match input.which().unwrap() {
        schema_capnp::type_::Which::Text(_) |
        schema_capnp::type_::Which::Data(_) |
        schema_capnp::type_::Which::List(_) |
        schema_capnp::type_::Which::Struct(_) |
        schema_capnp::type_::Which::Interface(_) |
        schema_capnp::type_::Which::AnyPointer(_) => true,
        _ => false
    };

    let bit_multi = match input.which().unwrap() {
        schema_capnp::type_::Which::Void(_) => 1,
        schema_capnp::type_::Which::Bool(_) => 1,
        schema_capnp::type_::Which::Int8(_) => 1,
        schema_capnp::type_::Which::Int16(_) => 2,
        schema_capnp::type_::Which::Int32(_) => 4,
        schema_capnp::type_::Which::Int64(_) => 8,
        schema_capnp::type_::Which::Uint8(_) => 1,
        schema_capnp::type_::Which::Uint16(_) => 2,
        schema_capnp::type_::Which::Uint32(_) => 4,
        schema_capnp::type_::Which::Uint64(_) => 8,
        schema_capnp::type_::Which::Float32(_) => 4,
        schema_capnp::type_::Which::Float64(_) => 8,
        schema_capnp::type_::Which::Enum(_) => 2,
        _ => 1
    };

    if is_ptr {
        format!("dataSectionLengthInWords + {}", offset)
    } else {
        format!("{}", offset * bit_multi)
    }
}

fn handle_slot(
    gen: &GeneratorContext,
    field_name: &str,
    slot_reader: schema_capnp::field::slot::Reader,
    getters: &mut Vec<FormattedText>,
    setters: &mut Vec<FormattedText>,
    in_group: Option<(String, u32)>,
    node_id: u64,
    is_nested: bool
) -> capnp::Result<()> {
    let offset = build_offset(slot_reader.get_offset() as usize, slot_reader.get_type()?);
    let (read_type, read_func, read_extra) = handle_type(gen, node_id, slot_reader.get_type()?)?;
    let default_value = slot_reader.get_default_value()?;
    let default = default_value.which()?;
    let value: String;
    match default {
        schema_capnp::value::Which::Void(_) => value = "".to_string(),
        schema_capnp::value::Which::Bool(v) => value = v.to_string(),
        schema_capnp::value::Which::Int8(v) => value = v.to_string(),
        schema_capnp::value::Which::Int16(v) => value = v.to_string(),
        schema_capnp::value::Which::Int32(v) => value = v.to_string(),
        schema_capnp::value::Which::Int64(v) => value = v.to_string(),
        schema_capnp::value::Which::Uint8(v) => value = v.to_string(),
        schema_capnp::value::Which::Uint16(v) => value = v.to_string(),
        schema_capnp::value::Which::Uint32(v) => value = v.to_string(),
        schema_capnp::value::Which::Uint64(v) => value = v.to_string(),
        schema_capnp::value::Which::Float32(v) => value = v.to_string(),
        schema_capnp::value::Which::Float64(v) => value = v.to_string(),
        _ => value = "".to_string(),
    };
    let default_value = "";

    match in_group {
        Some((group, discrim)) => {
            let discrim = discrim * 2; // discriminate is a 2 byte integer

            getters.push(Branch(vec![Line(format!(
                "{}? get {} {{",
                read_type,
                field_name,
            )),
            Indent(Box::new(Branch(vec![
                Line("var tag = which();".to_string()),
                Line(format!("if(tag != null && tag == {}Tag.{})", group, field_name.to_case(Case::Pascal))),
                Indent(Box::new(Line(format!("return segmentView.{}({}{}{});", read_func,
                offset,
                read_extra.unwrap_or(String::new()),
                value))))
            
            ]))), Line("}".to_string())]));

            match handle_write_type(gen, slot_reader.get_type()?)? {
                WriteResult::Simple(ty, func) => {
                    setters.push(Branch(vec![
                        Line(format!("set {}({} value) {{", field_name, ty)),
                        Indent(Box::new(Branch(vec![
                            Line(format!("segmentView.setUInt16({}, {}Tag.{}.index);", discrim, group, field_name.to_string().to_case(Case::Pascal))),
                            Line(format!("segmentView.{}({}, value{});", func, offset, value))
                        ]))),
                        Line("}".to_string())
                    ]))
                },
                WriteResult::AnyPointer => {
                    setters.push(Branch(vec![
                        Line(format!("capnp.AnyPointerBuilder get init{} {{", field_name.to_case(Case::Pascal))),
                        Indent(Box::new(Branch(vec![
                            Line(format!("segmentView.setUInt16({}, {}Tag.{}.index);", discrim, group, field_name.to_string().to_case(Case::Pascal))),
                            Line(format!(
                                "return segmentView.setAnyPointer({});",
                                offset,
                            ))
                        ]))),
                        Line("}".to_string()),
                        BlankLine
                    ]));
                },
                WriteResult::Enum(enum_ty) => {
                    setters.push(Branch(vec![
                        Line(format!("set {}({} value) {{", field_name, enum_ty)),
                        Indent(Box::new(Branch(vec![
                            Line(format!("segmentView.setUInt16({}, {}Tag.{}.index);", discrim, group, field_name.to_string().to_case(Case::Pascal))),
                            Line(format!("segmentView.setUInt16({}, value.index{});", offset, value))
                        ]))),
                        Line("}".to_string())
                    ]))
                },
                WriteResult::Struct(struct_name) => {
                    setters.push(Branch(vec![
                        Line(format!("{}Builder init{}() {{", struct_name, field_name.to_case(Case::Pascal))),
                        Indent(Box::new(Branch(vec![
                            Line(format!("segmentView.setUInt16({}, {}Tag.{}.index);", discrim, group, field_name.to_string().to_case(Case::Pascal))),
                            Line(format!(
                                "return segmentView.newStruct({}, {}().builder);",
                                offset, struct_name
                            ))
                        ]))),
                        Line("}".to_string()),
                        BlankLine,
                        Line(format!("set {}({}Reader value) {{", field_name, struct_name)),
                        Indent(Box::new(Branch(vec![
                            Line(format!("segmentView.setUInt16({}, {}Tag.{}.index);", discrim, group, field_name.to_string().to_case(Case::Pascal))),
                            Line(format!(
                                "segmentView.setStruct({}, value{});",
                                offset, value
                            ))
                        ]))),
                        Line("}".to_string()),
                        BlankLine
                    ]))
                },
                WriteResult::List(list_type, list_func, list_extra) => {
                    setters.push(Branch(vec![
                        Line(format!(
                            "{} init{}(core.int len) {{",
                            list_type,
                            field_name.to_case(Case::Pascal)
                        )),
                        Indent(Box::new(Branch(vec![
                            Line(format!("segmentView.setUInt16({}, {}Tag.{}.index);", discrim, group, field_name.to_string().to_case(Case::Pascal))),
                            Line(format!(
                                "return segmentView.{}({}, len{});",
                                list_func,
                                offset,
                                list_extra.unwrap_or_else(String::new)
                            ))
                        ]))),
                        Line("}".to_string()),
                        BlankLine
                    ]));
                }
            }
        },
        None => {
            getters.push(Branch(vec![Line(format!(
                "{} get {} => segmentView.{}({}{}{});",
                read_type,
                field_name,
                read_func,
                offset,
                read_extra.unwrap_or(String::new()),
                value
            ))]));

            match handle_write_type(gen, slot_reader.get_type()?)? {
                WriteResult::Simple(ty, func) => {
                    setters.push(Branch(vec![Line(format!(
                        "set {} ({} value) => segmentView.{}({}, value{});",
                        field_name, ty, func, offset, value
                    ))]));                    
                }
                WriteResult::AnyPointer => {
                    setters.push(Branch(vec![Line(format!(
                        "capnp.AnyPointerBuilder get init{} => segmentView.setAnyPointer({});",
                        field_name.to_case(Case::Pascal), offset
                    ))]));                    
                }
                WriteResult::Enum(enum_ty) => {
                    setters.push(Branch(vec![Line(format!(
                        "set {} ({} value) => segmentView.setUInt16({}, value.index{});",
                        field_name, enum_ty, offset, value
                    ))]));
                }
                WriteResult::Struct(struct_name) => {
                    setters.push(Branch(vec![
                        Line(format!(
                            "{}Builder init{}() =>",
                            struct_name,
                            field_name.to_case(Case::Pascal)
                        )),
                        Indent(Box::new(Line(format!(
                            "segmentView.newStruct({}, {}().builder);",
                            offset, struct_name
                        )))),
                        Line(format!(
                            "set {} ({}Reader value) => segmentView.setStruct({}, value{});",
                            field_name, struct_name, offset, value
                        )),
                    ]));
                }
                WriteResult::List(list_type, list_func, list_extra) => {
                    setters.push(Branch(vec![
                        Line(format!(
                            "{} init{}(core.int len) =>",
                            list_type,
                            field_name.to_case(Case::Pascal)
                        )),
                        Indent(Box::new(Line(format!(
                            "segmentView.{}({}, len{});",
                            list_func,
                            offset,
                            list_extra.unwrap_or_else(String::new)
                        )))),
                    ]));
                }
            }
        },
    }
    Ok(())
}

fn handle_group(
    gen: &GeneratorContext,
    name: &str,
    group_reader: schema_capnp::field::group::Reader,
    getters: &mut Vec<FormattedText>,
    setters: &mut Vec<FormattedText>,
    nested_output: &mut Vec<FormattedText>,
    in_group: Option<(String, u32)>,
    node_id: u64,
    is_nested: bool
) -> capnp::Result<()> {
    use schema_capnp::node;

    let group_name = gen
        .get_last_name(group_reader.get_type_id())?
        .to_case(Case::Pascal);

    getters.push(Branch(vec![Line(format!(
        "{}Reader get {} => {}Reader(segmentView, dataSectionLengthInWords);",
        group_name, name, group_name
    ))]));
    setters.push(Branch(vec![Line(format!(
        "{}Builder get {} => {}Builder(segmentView, dataSectionLengthInWords);",
        group_name, name, group_name
    ))]));

    if is_nested {
        return Ok(());
    }

    let mut inner_getters = Vec::new();
    let mut inner_setters = Vec::new();

    let group_id = group_reader.get_type_id();

    match gen.node_map[&group_id].which()? {
        node::Which::Struct(st) => {
            let fields = st.get_fields()?;

            if st.get_discriminant_count() != 0 {
                nested_output.push(Branch(vec![
                    Line(format!("enum {}Tag {{", group_name)),
                    Indent(Box::new(Branch(
                        fields
                            .iter()
                            .map(|field| {
                                Line(format!(
                                    "{},",
                                    field.get_name().unwrap().to_case(Case::Pascal)
                                ))
                            })
                            .collect(),
                    ))),
                    Line("}".to_string()),
                    BlankLine,
                ]));
                inner_getters.push(Branch(vec![
                    Line(format!("{}Tag? which() {{", group_name)),
                    Indent(Box::new(Branch(vec![Line(format!(
                        "return segmentView.getEnum({}, {}Tag.values);",
                        st.get_discriminant_offset() * 2,
                        group_name
                    ))]))),
                    Line("}".to_string()),
                    BlankLine,
                ]));
            }

            for field in fields.iter() {
                let name = escape(field.get_name()?.to_string());
                
                let in_group = if field.get_discriminant_value() != schema_capnp::field::NO_DISCRIMINANT {
                    Some((group_name.clone(), st.get_discriminant_offset()))
                } else {
                    None
                };

                match field.which()? {
                    schema_capnp::field::Which::Slot(slot) => {
                        handle_slot(
                            gen,
                            &name,
                            slot,
                            &mut inner_getters,
                            &mut inner_setters,
                            in_group,
                            node_id,
                            is_nested
                        )?;
                    }
                    schema_capnp::field::Which::Group(group) => {
                        handle_group(
                            gen,
                            &name,
                            group,
                            &mut inner_getters,
                            &mut inner_setters,
                            nested_output,
                            in_group,
                            node_id,
                            is_nested
                        )?;
                    }
                }
            }
        }
        _ => panic!(),
    }

    nested_output.push(Branch(vec![
        Line(format!("class {}Reader {{", group_name)),
        Indent(Box::new(Branch(vec![
            Line("final capnp.SegmentView segmentView;".to_string()),
            Line("final core.int dataSectionLengthInWords;".to_string()),
            Line(format!(
                "const {}Reader(this.segmentView, this.dataSectionLengthInWords);",
                group_name
            )),
            Line(format!("static {}Reader from(", group_name)),
            Indent(Box::new(Branch(vec![
                Line("capnp.SegmentView segmentView,".to_string()),
                Line("core.int dataSectionLengthInWords,".to_string()),
            ]))),
            Line(") =>".to_string()),
            Indent(Box::new(Indent(Box::new(Line(format!(
                "{}Reader(segmentView, dataSectionLengthInWords);",
                group_name
            )))))),
            BlankLine,
            Branch(inner_getters),
        ]))),
        Line("}".to_string()),
        BlankLine,
    ]));

    nested_output.push(Branch(vec![
        Line(format!("class {}Builder {{", group_name)),
        Indent(Box::new(Branch(vec![
            Line("final capnp.SegmentView segmentView;".to_string()),
            Line("final core.int dataSectionLengthInWords;".to_string()),
            Line(format!(
                "const {}Builder(this.segmentView, this.dataSectionLengthInWords);",
                group_name
            )),
            Line(format!("static {}Builder from(", group_name)),
            Indent(Box::new(Branch(vec![
                Line("capnp.SegmentView segmentView,".to_string()),
                Line("core.int dataSectionLengthInWords".to_string()),
            ]))),
            Line(") =>".to_string()),
            Indent(Box::new(Indent(Box::new(Line(format!(
                "{}Builder(segmentView, dataSectionLengthInWords);",
                group_name
            )))))),
            BlankLine,
            Line(format!("{}Reader get reader => {}Reader(segmentView, dataSectionLengthInWords);", group_name, group_name)),
            BlankLine,
            Branch(inner_setters),
        ]))),
        Line("}".to_string()),
        BlankLine,
    ]));

    Ok(())
}

fn generate_node(
    gen: &GeneratorContext,
    node_id: u64,
    node_name: &str,
    // Ugh. We need this to deal with the anonymous Params and Results
    // structs that go with RPC methods.
    parent_node_id: Option<u64>,
    addl_files: &mut Vec<(String, FormattedText)>
) -> ::capnp::Result<FormattedText> {
    use crate::schema_capnp::*;

    let send_node_id = parent_node_id.unwrap_or(node_id);

    let mut output: Vec<FormattedText> = Vec::new();
    let mut nested_output: Vec<FormattedText> = Vec::new();

    let node_reader = &gen.node_map[&node_id];
    let nested_nodes = node_reader.get_nested_nodes()?;
    for nested_node in nested_nodes.iter() {
        let id = nested_node.get_id();
        nested_output.push(generate_node(gen, id, &gen.get_last_name(id)?, None, addl_files)?);
    }

    match node_reader.which()? {
        node::File(_) => {
            output.push(Branch(nested_output));
        }
        node::Struct(struct_reader) => {
            let params = node_reader.parameters_texts(gen, parent_node_id);
            let is_nested = parent_node_id.is_some();
            let node_name_camel = node_name.to_case(Case::Pascal);
            output.push(BlankLine);

            let data_size = struct_reader.get_data_word_count();
            let pointer_size = struct_reader.get_pointer_count();
            let discriminant_count = struct_reader.get_discriminant_count();
            let discriminant_offset = struct_reader.get_discriminant_offset();

            let mut getters = Vec::new();
            let mut setters = Vec::new();
            let mut union_fields = Vec::new();

            let fields = struct_reader.get_fields()?;
            for field in fields.iter() {
                let name = escape(get_field_name(field)?.to_string());
                let discriminant_value = field.get_discriminant_value();
                let is_union_field = discriminant_value != field::NO_DISCRIMINANT;

                if !is_union_field {
                    match field.which()? {
                        field::Which::Slot(slot_reader) => {
                            handle_slot(gen, &name, slot_reader, &mut getters, &mut setters, None, send_node_id, is_nested)?;
                        }
                        field::Which::Group(group_reader) => {
                            handle_group(
                                gen,
                                &name,
                                group_reader,
                                &mut getters,
                                &mut setters,
                                &mut nested_output,
                                None,
                                send_node_id,
                                is_nested
                            )?;
                        }
                    };
                } else {
                    union_fields.push(field);
                    match field.which()? {
                        field::Which::Slot(slot) => {
                            handle_slot(
                                gen,
                                &name,
                                slot,
                                &mut getters,
                                &mut setters,
                                Some((node_name_camel.to_string(), discriminant_offset)),
                                send_node_id,
                                is_nested
                            )?;
                        }
                        field::Which::Group(group_reader) => {
                            handle_group(
                                gen,
                                &name,
                                group_reader,
                                &mut getters,
                                &mut setters,
                                &mut nested_output,
                                Some((node_name_camel.to_string(), discriminant_offset)),
                                send_node_id,
                                is_nested
                            )?;
                        }
                    }
                }
            }

            if !union_fields.is_empty() {
                getters.push(Branch(vec![
                    // BlankLine,
                    Line(format!("{}Tag? which() {{", node_name_camel)),
                    Indent(Box::new(Branch(vec![Line(format!(
                        "return segmentView.getEnum({}, {}Tag.values);",
                        discriminant_offset * 2, node_name_camel
                    ))]))),
                    Line("}".to_string()),
                ]));
                nested_output.push(Branch(vec![
                    Line(format!("enum {}Tag {{", node_name_camel)),
                    Indent(Box::new(Branch(
                        union_fields
                            .iter()
                            .map(|field| {
                                Line(format!(
                                    "{},",
                                    field.get_name().unwrap().to_case(Case::Pascal)
                                ))
                            })
                            .collect(),
                    ))),
                    Line("}".to_string()),
                ]));
            }

            let is_generic = node_reader.get_is_generic();
            let bracketed_params = if params.params == "" {
                "".to_string()
            } else {
                format!("<{}>", params.params)
            };
            if is_generic {
                output.push(Line(format!(
                    "class {}{} {{ /* {} */",
                    node_name_camel,
                    bracketed_params,
                    params.expanded_list.join(",")
                )));
            } else {
                output.push(Line(format!("class {} {{", node_name_camel)));
            }

            output.push(Indent(Box::new(Branch(vec![
                Line(format!(
                    "capnp.StructFactory<{}Reader{}> reader = {}Reader.from;",
                    node_name_camel, bracketed_params, node_name_camel
                )),
                Line(format!(
                    "capnp.StructBuilderFactory<{}Builder{}> builder = {}Builder.build;",
                    node_name_camel, bracketed_params, node_name_camel
                )),
                Line(format!("core.int ID = {};", format_u64(node_id)).to_string()),
            ]))));
            output.push(Line("}".to_string()));
            output.push(BlankLine);

            output.push(Branch(vec![
                Line(format!(
                    "class {}Reader{} {{",
                    node_name_camel, bracketed_params
                )),
                Indent(Box::new(Branch(vec![
                    Line("final capnp.SegmentView segmentView;".to_string()),
                    Line("final core.int dataSectionLengthInWords;".to_string()),
                    Line(format!(
                        "const {}Reader(this.segmentView, this.dataSectionLengthInWords);",
                        node_name_camel
                    )),
                    Line(format!(
                        "static {}Reader{} from{}(",
                        node_name_camel, bracketed_params, bracketed_params
                    )),
                    Indent(Box::new(Branch(vec![
                        Line("capnp.SegmentView segmentView,".to_string()),
                        Line("core.int dataSectionLengthInWords,".to_string()),
                    ]))),
                    Line(") =>".to_string()),
                    Indent(Box::new(Indent(Box::new(Line(format!(
                        "{}Reader(segmentView, dataSectionLengthInWords);",
                        node_name_camel
                    )))))),
                    BlankLine,
                    Branch(getters),
                ]))),
                Line("}".to_string()),
                BlankLine,
            ]));

            output.push(Branch(vec![
                Line(format!("class {}Builder{} {{", node_name_camel, bracketed_params)),
                Indent(Box::new(Branch(vec![
                    Line("final capnp.SegmentView segmentView;".to_string()),
                    Line(format!("final core.int dataSectionLengthInWords = {};", data_size)),
                    Line(format!("const {}Builder(this.segmentView);", node_name_camel)),
                    Line(format!("static capnp.BuilderReturn<{}Builder{}> build{}() {{", node_name_camel, bracketed_params, bracketed_params)),
                    Indent(Box::new(Line(format!("return capnp.BuilderReturn(capnp.Layout({}, {}), (root) => {}Builder(root));", data_size, pointer_size, node_name_camel)))),
                    Line("}".to_string()),
                    BlankLine,
                    Line(format!("{}Reader get reader => {}Reader(segmentView, dataSectionLengthInWords);", node_name_camel, node_name_camel)),
                    BlankLine,
                    Branch(setters)
                ]))),
                Line("}".to_string()),
            ]));

            output.push(Branch(nested_output));
        }

        node::Enum(enum_reader) => {
            let last_name = gen.get_last_name(node_id)?;
            output.push(BlankLine);

            let mut members = Vec::new();
            // let mut match_branches = Vec::new();
            let enumerants = enum_reader.get_enumerants()?;
            for ii in 0..enumerants.len() {
                let enumerant = capitalize_first_letter(get_enumerant_name(enumerants.get(ii))?);
                members.push(Line(format!("{},", enumerant)));
            }

            output.push(Branch(vec![
                Line(format!("enum {} {{", last_name)),
                Indent(Box::new(Branch(members))),
                Line("}".to_string()),
                BlankLine,
                Line(format!("extension {}TypeID on {} {{", last_name, last_name)),
                Indent(Box::new(Line(
                    format!("static const core.int ID = {};", format_u64(node_id)).to_string(),
                ))),
                Line("}".to_string()),
            ]));
        }

        node::Interface(interface) => {
            let params = node_reader.parameters_texts(gen, parent_node_id);

            let interface_id = node_id;
            let mut extended: String = "extends capnp_rpc.ServerDispatch".to_string();
            let mut abstract_funcs = Vec::new();
            let mut implemented_interfaces_dispatch = Vec::new();
            
           /* for super_class in interface.get_superclasses()?.iter() {
                let ast_name = gen.get_last_name(super_class.get_id())?;
                extended.push_str(&format!(", {}Server", ast_name));
                implemented_interfaces_dispatch.push(Branch(vec![
                    Line(format!("case {}:", format_u64(super_class.get_id()))),
                    Indent(Box::new(Branch(vec![
                        Line(format!("return (this as {}).dispatch(interfaceId, methodId, params, results);", ast_name))
                    ])))
                ]));
            } */

            // let mut inner_output = Vec::new();
            let mut client_methods = Vec::new();
            let mut this_interface_cases = Vec::new();

            for (function_id, function) in interface.get_methods()?.iter().enumerate() {
                let function_name = function.get_name()?;
                let node_name_camel = node_name.to_case(Case::Pascal);
                let function_cased = function_name.to_case(Case::Pascal);
                let params = format!("{}Params", function_cased);
                let results = format!("{}Results", function_cased);

                output.push(generate_node(gen, function.get_param_struct_type(), &params, Some(node_id), addl_files)?);
                output.push(generate_node(gen, function.get_result_struct_type(), &results, Some(node_id), addl_files)?);

                this_interface_cases.push(Branch(vec![
                    Line(format!("case {}:", function_id)),
                    Indent(Box::new(Line(format!("return {}(params.load({}Reader.from), results.initContent.initStruct({}Builder.build));", function_name, params, results))))
                ]));

                abstract_funcs.push(Branch(vec![
                    Line(format!("async.FutureOr<capnp_rpc.Status> {}({}Reader params, {}Builder results) =>", function_name, params, results)),
                    Indent(Box::new(Line("capnp_rpc.Status.unimplemented(\"Method not Implemented\");".to_string()))),
                    BlankLine
                ]));

                client_methods.push(Branch(vec![
                    Line(format!("capnp_rpc.Request<{}Builder,{}Reader> get {}Request =>", params, results, function_name)),
                    Indent(Box::new(Line(format!("capnp_rpc.Request.fromRaw(innerClient, {}, {}, {}Builder.build, {}Reader.from);", format_u64(interface_id), function_id, params, results)))),
                    BlankLine
                ]));
            }
            
            implemented_interfaces_dispatch.push(Branch(vec![
                Line(format!("case {}:", format_u64(interface_id))),
                Indent(Box::new(Branch(vec![
                    Line("switch(methodId) {".to_string()),
                    Indent(Box::new(Branch(this_interface_cases))),
                    Line("}".to_string())
                ])))
            ]));

            let file_name = gen.scope_map[&node_id].get(0).unwrap();
            let node_name_snake = node_name.to_case(Case::Snake);
            output.push(Branch(vec![
                Line(format!("class {} {{", node_name)),
                Indent(Box::new(Branch(vec![
                    Line(format!("capnp_rpc.ClientFactory<{}Client> clientBuilder = {}Client.fromRaw;", node_name, node_name))
                ]))),
                Line("}".to_string()),
                BlankLine
            ]));
            
            output.push(Branch(vec![
                Line(format!("class {}Client {{", node_name)),
                Indent(Box::new(Branch(vec![
                    Line("capnp_rpc.RawClient innerClient;".to_string()),
                    BlankLine,
                    Line(format!("{}Client(this.innerClient);", node_name)),
                    Line(format!("static {}Client fromRaw(capnp_rpc.RawClient client) => {}Client(client);", node_name, node_name)),
                    BlankLine,
                    Branch(client_methods),
                ]))),
                Line("}".to_string()),
                BlankLine
            ]));

            output.push(Branch(vec![
                Line(format!("class {}Server {} {{", node_name, extended)),
                Indent(Box::new(Branch(vec![
                    Line("@core.override".to_string()),
                    Line("async.FutureOr<capnp_rpc.Status> dispatch(core.int interfaceId, core.int methodId, capnp.StructPointer params, capnp_rpc.PayloadBuilder results) {".to_string()),
                    Indent(Box::new(Branch(vec![
                        Line("switch(interfaceId) {".to_string()),
                        Indent(Box::new(Branch(implemented_interfaces_dispatch))),
                        Line("}".to_string()),
                        Line("return capnp_rpc.Status.unimplemented(\"Method not implemented.\");".to_string()),
                    ]))),
                    Line("}".to_string())
                ]))),
                BlankLine,
                Indent(Box::new(Branch(abstract_funcs))),
                Line("}".to_string()),
                BlankLine
            ]));

            // addl_files.push((format!("{}_", node_name_snake), Branch(inner_output)))
        }

        node::Const(c) => {
            let needs_static = gen.scope_map.get(&node_id).unwrap().len() > 2;
            let maybe_static = if needs_static { "static " } else { "" };
            let styled_name = snake_to_upper_case(&gen.get_last_name(node_id)?);

            let typ = c.get_type()?;
            let formatted_text = match (typ.which()?, c.get_value()?.which()?) {
                (type_::Void(()), value::Void(())) => Line(format!(
                    "{}const capnp.NullableVoid {} = capnp.NullableVoid();",
                    maybe_static, styled_name
                )),
                (type_::Bool(()), value::Bool(b)) => Line(format!(
                    "{}const core.bool {} = {};",
                    maybe_static, styled_name, b
                )),
                (type_::Int8(()), value::Int8(i)) => Line(format!(
                    "{}const core.int {} = {};",
                    maybe_static, styled_name, i
                )),
                (type_::Int16(()), value::Int16(i)) => Line(format!(
                    "{}const core.int {} = {};",
                    maybe_static, styled_name, i
                )),
                (type_::Int32(()), value::Int32(i)) => Line(format!(
                    "{}const core.int {} = {};",
                    maybe_static, styled_name, i
                )),
                (type_::Int64(()), value::Int64(i)) => Line(format!(
                    "{}const core.int {} = {};",
                    maybe_static, styled_name, i
                )),
                (type_::Uint8(()), value::Uint8(i)) => Line(format!(
                    "{}const core.int {} = {};",
                    maybe_static, styled_name, i
                )),
                (type_::Uint16(()), value::Uint16(i)) => Line(format!(
                    "{}const core.int {} = {};",
                    maybe_static, styled_name, i
                )),
                (type_::Uint32(()), value::Uint32(i)) => Line(format!(
                    "{}const core.int {} = {};",
                    maybe_static, styled_name, i
                )),
                (type_::Uint64(()), value::Uint64(i)) => Line(format!(
                    "{}const core.int {} = {};",
                    maybe_static, styled_name, i
                )),

                (type_::Float32(()), value::Float32(f)) => Line(format!(
                    "{}const core.double {} = {:e};",
                    maybe_static, styled_name, f
                )),

                (type_::Float64(()), value::Float64(f)) => Line(format!(
                    "{}const core.double {} = {:e};",
                    maybe_static, styled_name, f
                )),

                (type_::Enum(e), value::Enum(v)) => {
                    if let Some(node) = gen.node_map.get(&e.get_type_id()) {
                        match node.which()? {
                            node::Enum(e) => {
                                let enumerants = e.get_enumerants()?;
                                if (v as u32) < enumerants.len() {
                                    let variant = capitalize_first_letter(get_enumerant_name(
                                        enumerants.get(v as u32),
                                    )?);
                                    let type_string = typ.type_string(gen, Leaf::Owned)?;
                                    Line(format!(
                                        "{}const {} {} = {}.{};",
                                        maybe_static,
                                        styled_name,
                                        &type_string,
                                        &type_string,
                                        variant
                                    ))
                                } else {
                                    return Err(Error::failed(format!(
                                        "enumerant out of range: {}",
                                        v
                                    )));
                                }
                            }
                            _ => {
                                return Err(Error::failed(format!(
                                    "bad enum type ID: {}",
                                    e.get_type_id()
                                )));
                            }
                        }
                    } else {
                        return Err(Error::failed(format!(
                            "bad enum type ID: {}",
                            e.get_type_id()
                        )));
                    }
                }

                (type_::Text(()), value::Text(t)) => Line(format!(
                    "{}const core.String {} = {:?};",
                    maybe_static, styled_name, t?
                )),
                (type_::Data(()), value::Data(d)) => Line(format!(
                    "{}const core.List<core.int> {} = {:?};",
                    maybe_static, styled_name, d?
                )),

                (type_::List(_), value::List(v)) => {
                    generate_pointer_constant(gen, &styled_name, typ, v)?
                }
                (type_::Struct(_), value::Struct(v)) => {
                    generate_pointer_constant(gen, &styled_name, typ, v)?
                }

                (type_::Interface(_t), value::Interface(())) => {
                    return Err(Error::unimplemented(format!("interface constants")));
                }
                (type_::AnyPointer(_), value::AnyPointer(_pr)) => {
                    return Err(Error::unimplemented(format!("anypointer constants")));
                }

                _ => {
                    return Err(Error::failed(format!("type does not match value")));
                }
            };

            output.push(formatted_text);
        }

        node::Annotation(_annotation_reader) => (),
    }

    Ok(Branch(output))
}

// The capnp crate defines a blanket impl of capnp::Read for R where R: std::io::Read,
// but we can't use that here because it lives behind the "std" feature flag.
struct ReadWrapper<R>
where
    R: std::io::Read,
{
    inner: R,
}

impl<R> capnp::io::Read for ReadWrapper<R>
where
    R: std::io::Read,
{
    fn read(&mut self, buf: &mut [u8]) -> capnp::Result<usize> {
        loop {
            match std::io::Read::read(&mut self.inner, buf) {
                Ok(n) => return Ok(n),
                Err(e) if e.kind() == std::io::ErrorKind::Interrupted => {}
                Err(e) => return Err(convert_io_err(e)),
            }
        }
    }
}
